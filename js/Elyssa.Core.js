// Generated by CoffeeScript 1.4.0
(function() {
  var __slice = [].slice;

  (function(window, document, Function, String) {
    "use strict";

    /*
        Console object fixes
    */

    var console, i, lastTime, method, methods, noop, vendors, x, _i, _j, _len, _len1;
    noop = function() {};
    methods = ['assert', 'clear', 'count', 'debug', 'dir', 'dirxml', 'error', 'exception', 'group', 'groupCollapsed', 'groupEnd', 'info', 'log', 'markTimeline', 'profile', 'profileEnd', 'table', 'time', 'timeEnd', 'timeStamp', 'trace', 'warn'];
    console = (window.console || (window.console = {}));
    for (_i = 0, _len = methods.length; _i < _len; _i++) {
      i = methods[_i];
      method = methods[i];
      console[method] || (console[method] = noop);
    }
    /*
       Extending objects
    */

    window.extend = function() {
      var key, obj, objects, target, value, _j, _len1;
      target = arguments[0], objects = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      for (_j = 0, _len1 = objects.length; _j < _len1; _j++) {
        obj = objects[_j];
        for (key in obj) {
          value = obj[key];
          target[key] = value;
        }
      }
      return target;
    };
    /*
        Cloning objects
    */

    window.clone = function(obj) {
      var flags, key, newInstance;
      if (!(obj != null) || typeof obj !== 'object') {
        return obj;
      }
      if (obj instanceof Date) {
        return new Date(obj.getTime());
      }
      if (obj instanceof RegExp) {
        flags = '';
        if (obj.global != null) {
          flags += 'g';
        }
        if (obj.ignoreCase != null) {
          flags += 'i';
        }
        if (obj.multiline != null) {
          flags += 'm';
        }
        if (obj.sticky != null) {
          flags += 'y';
        }
        return new RegExp(obj.source, flags);
      }
      newInstance = new obj.constructor();
      for (key in obj) {
        newInstance[key] = window.clone(obj[key]);
      }
      return newInstance;
    };
    /*
        'is' is a pretty good function name in my opinion, 
        but already a pre-defined keyword in CoffeeScript, 
        'check' is a better function name if you want to just 
        use the function without the 'window' prefix
    */

    window.is = window.check = function(variable) {
      "use strict";

      var checkType, result, stringedVar, typeName, types;
      stringedVar = {}.toString.call(variable);
      typeName = stringedVar.slice(8, stringedVar.length - 1).toLowerCase();
      checkType = function(typeString, cb, inverse) {
        if (inverse) {
          if (typeName !== typeString) {
            if (typeof cb === "function") {
              cb(variable);
            }
          }
        } else {
          if (typeName === typeString) {
            if (typeof cb === "function") {
              cb(variable);
            }
          }
        }
        /*
                Else is a reserved keyword, while CoffeeScript interpolates it correctly,
                it can only be written as check(...).['else']...
                check(...).otherwise(...) is a better choice, if using plain JavaScript
        */

        result["else"] = result.otherwise = function(cb) {
          return checkType(typeString, cb, !inverse);
        };
        return result;
      };
      types = function(inverse) {
        return {
          valid: function(cb) {
            if (inverse) {
              if (variable == null) {
                cb(variable);
              }
            } else {
              if (variable != null) {
                cb(variable);
              }
            }
            return this;
          },
          undefined: function(cb) {
            return checkType("undefined", cb, inverse);
          },
          "null": function(cb) {
            return checkType("null", cb, inverse);
          },
          string: function(cb) {
            return checkType("string", cb, inverse);
          },
          number: function(cb) {
            return checkType("number", cb, inverse);
          },
          object: function(cb) {
            return checkType("object", cb, inverse);
          },
          array: function(cb) {
            return checkType("array", cb, inverse);
          },
          "function": function(cb) {
            return checkType("function", cb, inverse);
          }
        };
      };
      result = types(false);
      result.not = types(true);
      return result;
    };
    /*
        Provides a hashcode for strings
    */

    String.prototype.hashCode = function() {
      var char, hash, _j, _len1;
      hash = 0;
      if (this.length === 0) {
        return hash;
      }
      for (_j = 0, _len1 = this.length; _j < _len1; _j++) {
        i = this[_j];
        char = this.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash;
      }
      return hash;
    };
    /*
        Syntactic sugar for properties
    */

    Function.prototype.property = function(prop, desc) {
      return Object.defineProperty(this.prototype, prop, desc);
    };
    /*
       requestAnim shim layer by Paul Irish
    */

    lastTime = 0;
    vendors = ["ms", "moz", "webkit", "o"];
    for (_j = 0, _len1 = vendors.length; _j < _len1; _j++) {
      x = vendors[_j];
      window.requestAnimationFrame = window[vendors[x] + "RequestAnimationFrame"];
      window.cancelAnimationFrame = window[vendors[x] + "CancelAnimationFrame"] || window[vendors[x] + "CancelRequestAnimationFrame"];
    }
    if (!window.requestAnimationFrame) {
      window.requestAnimationFrame = function(callback, element) {
        var currTime, id, timeToCall;
        currTime = Date.now();
        timeToCall = Math.max(0, 16 - (currTime - lastTime));
        id = window.setTimeout(function() {
          return callback(currTime + timeToCall);
        }, timeToCall);
        lastTime = currTime + timeToCall;
        return id;
      };
    }
    if (!window.cancelAnimationFrame) {
      window.cancelAnimationFrame = function(id) {
        return clearTimeout(id);
      };
    }
    return null;
  })(this, document, Function, String);

  (function(window, Elyssa) {})(this, this.Elyssa || (this.Elyssa = {}));

  (function(window, Elyssa) {
    return Elyssa.Math = {
      clamp: function(value, min, max) {
        if (min == null) {
          min = 0.0;
        }
        if (max == null) {
          max = 1.0;
        }
        if ((min <= value && value <= max)) {
          return value;
        } else {
          if (value > max) {
            return max;
          } else {
            return min;
          }
        }
      }
    };
  })(this, this.Elyssa || (this.Elyssa = {}));

}).call(this);
